local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

--
local plr = game.Players.LocalPlayer
local SetNetworkOwnerRemote = game.ReplicatedStorage.GrabEvents.SetNetworkOwner
local SpawnToyRemoteFunction = game.ReplicatedStorage.MenuToys.SpawnToyRemoteFunction
local SpawnedInToys = game.Workspace:WaitForChild(plr.Name.."SpawnedInToys")
--

local Window = Fluent:CreateWindow({
	Title = "Abyss",
	SubTitle = "By: @Royal_No0bs",
	TabWidth = 160,
	Size = UDim2.fromOffset(580, 460),
	Acrylic = false, -- The blur may be detectable, setting this to false disables blur entirely
	Theme = "VeryDark",
	MinimizeKey = Enum.KeyCode.M -- Used when theres no MinimizeKeybind
})

--Fluent provides Lucide Icons https://lucide.dev/icons/ for the tabs, icons are optional
local Tabs = {
	ToyAuras = Window:AddTab({ Title = "Toy Auras", Icon = "" }),
	Player = Window:AddTab({ Title = "Player", Icon = "" }),
	Effects = Window:AddTab({ Title = "Effects", Icon = "" }),
	ESP = Window:AddTab({ Title = "ESP", Icon = "" })
}

local Options = Fluent.Options

do
	-----------------------------------------------------
	local Include = Tabs.ToyAuras:AddDropdown("Include", {
		Title = "Include",
		Values = {"Objects And Players","Objects","Players"},
		Multi = false,
		Default = 1,
	})
	local FlingAura = Tabs.ToyAuras:AddToggle("FlingAura", {Title = "Fling Aura", Default = false })
	local FlingForce = Tabs.ToyAuras:AddSlider("FlingForce", {
		Title = "Fling Force",
		Description = nil,
		Default = 100,
		Min = 0,
		Max = 1000000,
		Rounding = 1
	})

	function FlingPart(part)
		local chr = plr.Character
		SetNetworkOwnerRemote:FireServer(part,part.CFrame)
		wait(0.05)
		local bodyForce = Instance.new("BodyForce")
		local direction = (part.Position - chr:WaitForChild("HumanoidRootPart").Position).unit
		bodyForce.Force = direction * Options.FlingForce.Value
		bodyForce.Parent = part
		game:GetService("Debris"):AddItem(bodyForce, 0.1)
	end

	local RunService = game:GetService("RunService")
	RunService.Stepped:Connect(function()
		if Options.FlingAura.Value == true and plr.Character then
			local chr = plr.Character
			local radius = 15
			local region = Region3.new(
				chr:WaitForChild("HumanoidRootPart").Position - Vector3.new(radius, radius, radius),
				chr:WaitForChild("HumanoidRootPart").Position + Vector3.new(radius, radius, radius)
			)

			local parts = workspace:FindPartsInRegion3(region, nil, math.huge) -- No filtering by tags
			for _, part in ipairs(parts) do
				if not part.Anchored and part.Parent ~= chr and part:FindFirstChildOfClass("BodyForce") == nil and Options.FlingAura.Value == true then
					if Options.Include.Value == "Objects" then
						if part.Parent:FindFirstChildOfClass("Humanoid") == nil then
							FlingPart(part)
						end
					elseif Options.Include.Value == "Players" then
						if part.Parent:FindFirstChildOfClass("Humanoid") then
							FlingPart(part)
						end
					elseif Options.Include.Value == "Objects And Players" then
						FlingPart(part)
					end
				end
			end
		end
	end)
	-----------------------------------------------------
	local WalkSpeed = Tabs.Player:AddToggle("WalkSpeed", {Title = "WalkSpeed", Default = false })
	local Speed = Tabs.Player:AddSlider("Speed", {
		Title = "Speed",
		Description = "The amount of speed you want",
		Default = 16,
		Min = 16,
		Max = 200,
		Rounding = 1
	})
	local ThirdPerson = Tabs.Player:AddToggle("ThirdPerson", {Title = "3rd Person", Default = false })


	local userInputService = game:GetService("UserInputService")
	local movementVector = Vector3.new(0,0,0)
	userInputService.InputBegan:Connect(function(input, isProcessed)
		if isProcessed then return end
		if input.KeyCode == Enum.KeyCode.W then
			movementVector = movementVector + Vector3.new(0, 0, -1)
		elseif input.KeyCode == Enum.KeyCode.S then
			movementVector = movementVector + Vector3.new(0, 0, 1)
		elseif input.KeyCode == Enum.KeyCode.A then
			movementVector = movementVector + Vector3.new(-1, 0, 0)
		elseif input.KeyCode == Enum.KeyCode.D then
			movementVector = movementVector + Vector3.new(1, 0, 0)
		end
	end)
	userInputService.InputEnded:Connect(function(input, isProcessed)
		if isProcessed then return end
		if input.KeyCode == Enum.KeyCode.W then
			movementVector = movementVector - Vector3.new(0, 0, -1)
		elseif input.KeyCode == Enum.KeyCode.S then
			movementVector = movementVector - Vector3.new(0, 0, 1)
		elseif input.KeyCode == Enum.KeyCode.A then
			movementVector = movementVector - Vector3.new(-1, 0, 0)
		elseif input.KeyCode == Enum.KeyCode.D then
			movementVector = movementVector - Vector3.new(1, 0, 0)
		end
	end)

	game:GetService("RunService").RenderStepped:Connect(function(deltaTime)
		if movementVector.Magnitude > 0 and plr.Character and Options.WalkSpeed.Value == true then
			local character = plr.Character
			local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
			local movement = movementVector.Unit * Options.Speed.Value * deltaTime
			humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.new(movement)
		end
	end)

	ThirdPerson:OnChanged(function(Bool)
		if Bool == true then
			game.Players.LocalPlayer.CameraMode = Enum.CameraMode.Classic
			game.Players.LocalPlayer.CameraMaxZoomDistance = 100000
		else
			game.Players.LocalPlayer.CameraMode = Enum.CameraMode.LockFirstPerson
			game.Players.LocalPlayer.CameraMaxZoomDistance = 0
		end
	end)
end

--plr.Character.HumanoidRootPart.Changed:Connect(function()
--SetNetworkOwnerRemote:FireServer(plr.Character.HumanoidRootPart,plr.Character.HumanoidRootPart.CFrame)
--end)
-- Addons:
-- SaveManager (Allows you to have a configuration system)
-- InterfaceManager (Allows you to have a interface managment system)

-- Hand the library over to our managers
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- You can add indexes of elements the save manager should ignore
SaveManager:SetIgnoreIndexes({})

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)


Window:SelectTab(1)

Fluent:Notify({
	Title = "Fluent",
	Content = "The script has been loaded.",
	Duration = 8
})

-- You can use the SaveManager:LoadAutoloadConfig() to load a config
-- which has been marked to be one that auto loads!
SaveManager:LoadAutoloadConfig()
